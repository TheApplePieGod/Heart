#version 450

#define FRAME_BUFFER_BINDING 0
#define FRAME_BUFFER_SET 0
#include "../../frame_data/FrameBuffer.glsl"

#include "../../util/Misc.glsl"

#define MAX_NORMAL_DISTANCE 0.1f
#define MAX_PLANE_DISTANCE 5.0f

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 1) uniform sampler2D newGBuffer2;
layout(binding = 2) uniform sampler2D newGBuffer3;
layout(binding = 3) uniform sampler2D newGBufferDepth;
layout(binding = 4) uniform sampler2D filterInput;
layout(binding = 5, rgba16f) uniform writeonly image2D outColor;

layout(push_constant) uniform PushConstants
{
    uint iteration;
    uint padding;
    vec2 padding2;
} constants;

const float ATROUS_KERNEL_WEIGHTS[3] = { 1.0, 2.0 / 3.0, 1.0 / 6.0 };
const float GAUSSIAN_KERNEL_WEIGHTS[2][2] = {
    { 1.0 / 4.0, 1.0 / 8.0 },
    { 1.0 / 8.0, 1.0 / 16.0 }
};

float EdgeStoppingWeightNormal(vec3 centerNormal, vec3 sampleNormal, float sigma)
{
    return pow(clamp(dot(centerNormal, sampleNormal), 0.0f, 1.0f), sigma);
}

float EdgeStoppingWeightDepth(float centerDepth, float sampleDepth, float sigma)
{
    return -abs(centerDepth - sampleDepth) / sigma;
}

float EdgeStoppingWeightLuminance(float centerLuminance, float sampleLuminance, float phi)
{
    return -abs(centerLuminance - sampleLuminance) / phi;
}

float GetBlurredVariance(ivec2 coord)
{
    float sum = 0.0f;
    float sumw = 0.0f;

    // Gaussian blur
    const int radius = 1;
    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            ivec2 p = coord + ivec2(x, y);

            float k = GAUSSIAN_KERNEL_WEIGHTS[abs(x)][abs(y)];

            sum += texelFetch(filterInput, p, 0).a * k;
            sumw += k;
        }
    }

    return max(sum / sumw, 0.0f);
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    if (coord.x >= frameBuffer.data.screenSize.x || coord.y >= frameBuffer.data.screenSize.y)
        return;

    vec3 normal = texelFetch(newGBuffer2, coord, 0).xyz;
    float depth = texelFetch(newGBufferDepth, coord, 0).r;

    if (depth == 1.0 - float(frameBuffer.data.reverseDepth))
    {
        imageStore(outColor, coord, vec4(0.f));
        return;
    }

    vec4 centerColor = texelFetch(filterInput, coord, 0);
    float centerLuminance = Luminance(centerColor.rgb);
    vec3 centerNormal = texelFetch(newGBuffer2, coord, 0).xyz;
    float centerDepth = texelFetch(newGBuffer3, coord, 0).b;
    float variance = GetBlurredVariance(coord);

    vec3 colorSum = centerColor.rgb;
    float varianceSum = centerColor.a;
    float weightsSum = 1.0;
    float weightsSquareSum = 1.0;
    const int radius = 5;
    const int stepSize = 1 << constants.iteration;
    const float sigmaDepth = 1;
    const float sigmaNormal = 128;
    const float sigmaLuminance = 4;
    const float phi = sigmaLuminance * sqrt(variance + 1e-10);
    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            const ivec2 p = coord + ivec2(x, y) * stepSize;
            const bool inside = all(greaterThanEqual(p, ivec2(0, 0))) &&
                                all(lessThan(p, ivec2(frameBuffer.data.screenSize.xy)));
            const float kernel = ATROUS_KERNEL_WEIGHTS[abs(x)] * ATROUS_KERNEL_WEIGHTS[abs(y)];

            if (inside && (x != 0 || y != 0)) // Skip center pixel
            {
                const vec4 sampleColor = texelFetch(filterInput, p, 0);
                const float sampleLuminance = Luminance(sampleColor.rgb);

                vec3 sampleNormal = texelFetch(newGBuffer2, p, 0).rgb;
                float sampleDepth = texelFetch(newGBuffer3, p, 0).b;

                float wZ = EdgeStoppingWeightDepth(centerDepth, sampleDepth, sigmaDepth);
                float wN = EdgeStoppingWeightNormal(centerNormal, sampleNormal, sigmaNormal);
                float wL = EdgeStoppingWeightLuminance(centerLuminance, sampleLuminance, phi);
                float w = kernel * exp(wL + wZ) * wN;

                weightsSum += w;
                weightsSquareSum += w * w;
                colorSum += sampleColor.rgb * w;
                varianceSum += sampleColor.a * w * w;
            }
        }
    }

    vec4 finalColor = centerColor;
    if (weightsSum > 10e-6)
    {
        finalColor.rgb = colorSum / weightsSum;
        finalColor.a = varianceSum / weightsSquareSum;
    }

    imageStore(outColor, coord, finalColor);
}
