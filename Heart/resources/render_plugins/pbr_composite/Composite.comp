#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

#define FRAME_BUFFER_BINDING 0
#define FRAME_BUFFER_SET 0
#include "../frame_data/FrameBuffer.glsl"

#define LIGHT_BUFFER_BINDING 1
#define LIGHT_BUFFER_SET 0
#include "../lighting_data/LightingBuffer.glsl"

#include "../util/Misc.glsl"
#include "../util/Lighting.glsl"
#include "../util/BRDF.glsl"
#include "../ray_tracing/util/Query.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 2) uniform sampler2D newGBuffer1;
layout(binding = 3) uniform sampler2D newGBuffer2;
layout(binding = 4) uniform sampler2D newGBuffer3;
layout(binding = 5) uniform sampler2D newGBufferDepth;
layout(binding = 6) uniform sampler2D brdfTex;
layout(binding = 7) uniform sampler2D reflectionsTex;
layout(binding = 8, rgba16f) uniform writeonly image2D outColor;
layout(binding = 9) uniform accelerationStructureEXT tlas;

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    if (coord.x >= frameBuffer.data.screenSize.x || coord.y >= frameBuffer.data.screenSize.y)
        return;

    vec2 texCoord = (vec2(coord) + vec2(0.5)) / frameBuffer.data.screenSize.xy;
    vec4 gbuf1 = texelFetch(newGBuffer1, coord, 0);
    vec4 gbuf2 = texelFetch(newGBuffer2, coord, 0);
    vec4 gbuf3 = texelFetch(newGBuffer3, coord, 0);
    float depth = texelFetch(newGBufferDepth, coord, 0).r;

    vec3 P = ComputeWorldPositionFromDepth(texCoord, depth, frameBuffer.data.invViewProj);
    vec3 N = gbuf2.rgb;
    vec3 V = normalize(frameBuffer.data.cameraPos.xyz - P);
    vec3 albedo = gbuf1.rgb;
    float metalness = gbuf1.a;
    float roughness = gbuf2.a;

    vec3 F0 = mix(vec3(0.04), albedo.rgb, metalness);
    vec3 diffuse = mix(albedo.rgb * (vec3(1.0) - F0), vec3(0.0), metalness);

    uint shadowFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    vec3 shadowOrigin = P + N * 0.01;

    // Direct lighitng
    vec3 finalContribution = vec3(0.f);
    int lightCount = int(GET_LIGHT(0).position.x);
    for (int i = 1; i <= lightCount; i++)
    {
        LightEvalData data;
        if (GET_LIGHT(i).lightType == LIGHT_POINT)
            GetPointLightEvalData(data, GET_LIGHT(i), P, N);
        else if (GET_LIGHT(i).lightType == LIGHT_DIRECTIONAL)
            GetDirectionalLightEvalData(data, GET_LIGHT(i), N);

        if (data.nDotL <= 0)
            continue;

        if (!QueryVisibility(
            tlas, shadowOrigin, data.l, frameBuffer.data.clipPlanes.y, shadowFlags, 0xFF
        ))
            continue;

        finalContribution += EvaluateLightBRDF(data, N, V, F0, diffuse, roughness);
    }
    
    // Indirect lighting
    {
        vec3 R = reflect(-V, N);
        vec3 F = FresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);

        // TODO irradiance

        vec3 prefilteredColor = textureLod(reflectionsTex, texCoord, 0.0f).rgb;
        vec2 brdf = texture(brdfTex, vec2(max(dot(N, V), 0.0), roughness)).rg;
        vec3 specular = prefilteredColor * (F * brdf.x + brdf.y) * 2.0;

        finalContribution += specular;
    }

    imageStore(outColor, coord, vec4(finalContribution, 1.f));
}
