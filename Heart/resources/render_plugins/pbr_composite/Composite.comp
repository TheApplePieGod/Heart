#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

#define FRAME_BUFFER_BINDING 0
#define FRAME_BUFFER_SET 0
#include "../frame_data/FrameBuffer.glsl"

#define LIGHT_BUFFER_BINDING 1
#define LIGHT_BUFFER_SET 0
#include "../lighting_data/LightingBuffer.glsl"

#define CLUSTER_BUFFER_BINDING 2
#define CLUSTER_LIGHT_INDICES_BINDING 3
#define CLUSTER_LIGHT_GRID_BINDING 4
#define CLUSTER_DATA_BINDING 5
#define CLUSTER_BUFFER_SET 0
#include "../clustered_lighting/ClusterBuffer.glsl"

#include "../util/Misc.glsl"
#include "../util/Colormap.glsl"
#include "../util/Lighting.glsl"
#include "../util/BRDF.glsl"
#include "../ray_tracing/util/Query.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 6) uniform sampler2D newGBuffer1;
layout(binding = 7) uniform sampler2D newGBuffer2;
layout(binding = 8) uniform sampler2D newGBufferDepth;
layout(binding = 9) uniform sampler2D brdfTex;
layout(binding = 10, rgba16f) uniform writeonly image2D outColor;

#ifdef FLOURISH_RAY_TRACING
layout(binding = 11) uniform sampler2D reflectionsTex;
layout(binding = 12) uniform accelerationStructureEXT tlas;
#endif

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    if (coord.x >= frameBuffer.data.screenSize.x || coord.y >= frameBuffer.data.screenSize.y)
        return;

    // Skybox
    float depth = texelFetch(newGBufferDepth, coord, 0).r;
    if (depth == 1.0 - float(frameBuffer.data.reverseDepth))
        return;

    vec2 texCoord = (vec2(coord) + vec2(0.5)) / frameBuffer.data.screenSize.xy;
    vec4 gbuf1 = texelFetch(newGBuffer1, coord, 0);
    vec4 gbuf2 = texelFetch(newGBuffer2, coord, 0);

    vec3 P = ComputeWorldPositionFromDepth(texCoord, depth, frameBuffer.data.invViewProj);
    vec3 N = gbuf2.rgb;
    vec3 V = normalize(frameBuffer.data.cameraPos.xyz - P);
    vec3 albedo = gbuf1.rgb;
    float metalness = gbuf1.a;
    float roughness = gbuf2.a;

    vec3 F0 = mix(vec3(0.04), albedo.rgb, metalness);
    vec3 diffuse = mix(albedo.rgb * (vec3(1.0) - F0), vec3(0.0), metalness);

    uint shadowFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    vec3 shadowOrigin = P + N * 0.01;

    // Direct lighitng

    // Compute cluster indices
    // Flip the depth when appropriate so the close value is always zero
    uint clusterZ = GetClusterZIndex(
        frameBuffer.data.reverseDepth ? 1 - depth : depth,
        frameBuffer.data.clipPlanes.x,
        frameBuffer.data.clipPlanes.y,
        GET_CLUSTER_DATA().clusterScale,
        GET_CLUSTER_DATA().clusterBias
    );
    uint clusterIdx = GetClusterIndex(
        vec2(coord),
        frameBuffer.data.screenSize.xy,
        GET_CLUSTER_DATA().clusterDims,
        clusterZ
    );
    LightGrid grid = GetLightGrid(clusterIdx);
    vec3 finalContribution = vec3(0.f);
    for (uint i = 0; i < grid.lightCount; i++)
    {
        uint lightIndex = GetGridLightIndex(grid.offset, i) + 1;

        LightEvalData data;
        if (GET_LIGHT(lightIndex).lightType == LIGHT_POINT)
            GetPointLightEvalData(data, GET_LIGHT(lightIndex), P, N);
        else if (GET_LIGHT(lightIndex).lightType == LIGHT_DIRECTIONAL)
            GetDirectionalLightEvalData(data, GET_LIGHT(lightIndex), N);

        if (data.nDotL <= 0)
            continue;

        #ifdef FLOURISH_RAY_TRACING
            if (!QueryVisibility(
                tlas, shadowOrigin, data.l, data.dist, shadowFlags, 0xFF
            ))
                continue;
        #endif

        finalContribution += EvaluateLightBRDF(data, N, V, F0, diffuse, roughness);
    }
    
    // Indirect lighting
    {
        vec3 R = reflect(-V, N);
        vec3 F = FresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);

        vec3 kS = F;
        vec3 kD = 1.0 - kS;
        kD *= 1.0 - metalness;

        // TODO: env map
        vec3 irradiance = vec3(0.015);
        vec3 diffuse = irradiance * albedo;

        #ifdef FLOURISH_RAY_TRACING
            vec3 prefilteredColor = textureLod(reflectionsTex, texCoord, 0.0f).rgb;
        #else
            vec3 prefilteredColor = vec3(0.f);
        #endif

        vec2 brdf = texture(brdfTex, vec2(max(dot(N, V), 0.0), roughness)).rg;
        vec3 specular = prefilteredColor * (F * brdf.x + brdf.y) * 2.0;

        float occlusion = 1.0;
        finalContribution += (kD * diffuse + specular) * occlusion;
    }

    //finalContribution = textureLod(reflectionsTex, texCoord, 0.0f).rgb;
    //finalContribution = TurboColormap(float(grid.lightCount) / 100);

    imageStore(outColor, coord, vec4(finalContribution, 1.f));
}
